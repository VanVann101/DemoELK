input {
  beats {
    port => 5044
  }
}

filter {
  # Drop empty messages
  if [message] == "" or [message] =~ /^\s*$/ {
    drop { }
  }
  
  # Drop Filebeat internal messages
  if [message] =~ /^Filebeat/ or [message] =~ /^DBG/ {
    drop { }
  }
  
  # Drop standalone brackets (from batch boundaries)
  if [message] == "[" or [message] == "]" {
    drop { }
  }
  
  # Remove wrapping brackets from batched logs
  if [message] =~ /^\[.*\]$/ {
    mutate {
      gsub => [
        "message", "^\[", "",
        "message", "\]$", ""
      ]
    }
  }
  
  if [message] =~ /^inventory \|/ {
    grok {
      match => {
        "message" => [
          "^inventory \| %{TIMESTAMP_ISO8601:timestamp} \| level=%{WORD:level} \| item=%{INT:itemId} \| qty=%{INT:quantity} \| user=%{DATA:userId} \| traceId=%{DATA:traceId} \| msg=%{GREEDYDATA:msg}$"
        ]
      }
    }
    mutate {
      add_field => { "service" => "inventory-service" }
      remove_field => ["@version"]
    }
    date { match => ["timestamp", "ISO8601"] target => "@timestamp" }
  } else if [message] =~ /^timestamp=/ {
    # Logfmt format from payment-service
    grok {
      match => {
        "message" => [
          '^timestamp="%{TIMESTAMP_ISO8601:timestamp}" level=%{WORD:level} service=%{WORD:service} user="%{DATA:userId}" traceId="%{DATA:traceId}" message="%{GREEDYDATA:msg}"$'
        ]
      }
    }
    mutate {
      remove_field => ["@version"]
    }
    date { match => ["timestamp", "ISO8601"] target => "@timestamp" }
  } else {
    # For JSON logs from order-api (already parsed by Filebeat)
    # Check if this is already parsed JSON (has Level, TraceId fields)
    if [Level] {
      # Extract traceId
      if [TraceId] and ![traceId] {
        mutate { 
          add_field => { "traceId" => "%{[TraceId]}" }
          remove_field => ["TraceId"]
        }
      }
      
      # Normalize level to lowercase
      if [Level] and ![level] {
        mutate { 
          add_field => { "level" => "%{[Level]}" }
          lowercase => [ "level" ]
          remove_field => ["Level"]
        }
      }
      
      # Extract rendered message with substituted values
      if [RenderedMessage] {
        mutate { 
          add_field => { "msg" => "%{[RenderedMessage]}" }
          remove_field => ["RenderedMessage", "MessageTemplate"]
        }
      } else if [MessageTemplate] {
        mutate { 
          add_field => { "msg" => "%{[MessageTemplate]}" }
          remove_field => ["MessageTemplate"]
        }
      }
      
      # Clean up unnecessary fields
      mutate {
        remove_field => ["@version", "Properties", "SpanId", "Timestamp"]
      }
    } else {
      # Try to parse as JSON from message field
      json {
        source => "message"
        tag_on_failure => [ "_jsonparsefailure" ]
      }
      
      if "_jsonparsefailure" not in [tags] {
        # Extract service name
        if ![service] and [Properties][service] {
          mutate { add_field => { "service" => "%{[Properties][service]}" } }
        }
        
        # Extract traceId
        if [TraceId] {
          mutate { add_field => { "traceId" => "%{[TraceId]}" } }
        }
        
        # Extract level
        if [Level] {
          mutate { 
            add_field => { "level" => "%{[Level]}" }
            lowercase => [ "level" ]
          }
        }
        
        # Extract rendered message
        if [RenderedMessage] {
          mutate { add_field => { "msg" => "%{[RenderedMessage]}" } }
        } else if [MessageTemplate] {
          mutate { add_field => { "msg" => "%{[MessageTemplate]}" } }
        }
        
        # Clean up
        mutate {
          remove_field => ["@version", "MessageTemplate", "RenderedMessage", "Properties", "TraceId", "Level"]
        }
      } else {
        # JSON parsing failed - treat as plain text log
        mutate {
          add_field => { 
            "msg" => "%{message}"
            "level" => "info"
          }
          remove_field => ["@version"]
        }
        
        if ![service] {
          mutate { add_field => { "service" => "unknown-service" } }
        }
      }
    }
  }
}

output {
  elasticsearch {
    hosts => [ "http://elasticsearch:9200" ]
    index => "dotnet-logs-%{+YYYY.MM.dd}"
  }
  stdout { codec => rubydebug }
}

